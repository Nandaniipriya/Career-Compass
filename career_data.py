import pandas as pd
import os
from llm_service import get_career_advice, initialize_llm

# This module handles retrieving and processing career-related data
# In a full implementation, this would connect to actual datasets or APIs
# For this prototype, we'll use structured data generated by the LLM

def get_career_paths(education_level, interests):
    """
    Returns a list of career paths based on user's education level and interests.
    """
    # Base careers available for exploration
    all_careers = [
        "Software Engineer", "Data Scientist", "UX/UI Designer", 
        "Product Manager", "Digital Marketer", "Financial Analyst",
        "Healthcare Administrator", "Nurse Practitioner", "Teacher",
        "Research Scientist", "Environmental Engineer", "Human Resources Manager",
        "Business Analyst", "Content Creator", "Graphic Designer",
        "Cybersecurity Specialist", "Cloud Solutions Architect", "AI/ML Engineer",
        "Project Manager", "Management Consultant"
    ]
    
    # If no interests selected, return all careers
    if not interests:
        return all_careers
    
    # Filter careers based on interests
    # This is a simplified matching - a real implementation would use more sophisticated filtering
    career_by_interest = {
        "Technology": ["Software Engineer", "Data Scientist", "Cybersecurity Specialist", "Cloud Solutions Architect", "AI/ML Engineer"],
        "Healthcare": ["Healthcare Administrator", "Nurse Practitioner", "Research Scientist"],
        "Finance": ["Financial Analyst", "Business Analyst"],
        "Education": ["Teacher", "Research Scientist"],
        "Arts": ["UX/UI Designer", "Graphic Designer", "Content Creator"],
        "Business": ["Product Manager", "Human Resources Manager", "Management Consultant", "Project Manager"],
        "Engineering": ["Software Engineer", "Environmental Engineer", "Cloud Solutions Architect"],
        "Science": ["Data Scientist", "Research Scientist", "AI/ML Engineer"],
        "Social Service": ["Teacher", "Human Resources Manager"],
        "Environment": ["Environmental Engineer"],
        "Law": []
    }
    
    # Get matching careers based on interests
    matching_careers = []
    for interest in interests:
        matching_careers.extend(career_by_interest.get(interest, []))
    
    # Remove duplicates while preserving order
    filtered_careers = []
    for career in matching_careers:
        if career not in filtered_careers:
            filtered_careers.append(career)
    
    # If no matches, return all careers
    if not filtered_careers:
        return all_careers
    
    return filtered_careers

def get_job_growth_data(industry):
    """
    Returns job growth data for visualization.
    In a full implementation, this would fetch data from an API or database.
    """
    # Generate synthetic data for demonstration
    # In a real application, this would be replaced with actual data from APIs
    
    # Base data structure
    years = [2018, 2019, 2020, 2021, 2022, 2023]
    
    # Career-specific data based on industry
    industry_careers = {
        "Technology": ["Software Engineer", "Data Scientist", "Cybersecurity Specialist"],
        "Healthcare": ["Nurse Practitioner", "Healthcare Administrator", "Medical Technologist"],
        "Finance": ["Financial Analyst", "Investment Banker", "Accountant"],
        "Education": ["Teacher", "Educational Administrator", "Instructional Designer"],
        "Engineering": ["Civil Engineer", "Mechanical Engineer", "Electrical Engineer"],
        "Business": ["Business Analyst", "Project Manager", "Management Consultant"],
        "Arts & Media": ["Graphic Designer", "Content Creator", "Marketing Specialist"],
        "Science": ["Research Scientist", "Biologist", "Chemist"],
        "All Sectors": ["Software Engineer", "Healthcare Administrator", "Financial Analyst", "Teacher", "Project Manager"]
    }
    
    if industry not in industry_careers:
        industry = "All Sectors"
    
    careers = industry_careers[industry]
    
    # Generate data for each career
    data = []
    for career in careers:
        # Different growth patterns for different careers
        if "Engineer" in career or "Scientist" in career or "Data" in career:
            growth_pattern = [4.5, 5.2, 7.8, 12.3, 15.1, 18.7]  # High growth
        elif "Healthcare" in career or "Nurse" in career or "Medical" in career:
            growth_pattern = [3.8, 4.5, 9.7, 11.2, 12.8, 14.5]  # Steady high growth
        elif "Analyst" in career or "Manager" in career:
            growth_pattern = [3.2, 3.8, 4.2, 5.1, 6.7, 8.3]     # Moderate growth
        else:
            growth_pattern = [2.1, 2.3, 2.7, 3.2, 3.8, 4.5]     # Slower growth
            
        # Job openings based on growth pattern
        job_openings = [round(10000 * (1 + g/100)) for g in growth_pattern]
        
        # Locations with job distribution
        locations = ["United States", "Europe", "Asia", "Remote"]
        location_distribution = [0.45, 0.25, 0.2, 0.1]  # 45% US, 25% Europe, etc.
        
        for i, year in enumerate(years):
            for j, location in enumerate(locations):
                # Calculate job openings for this location
                location_openings = int(job_openings[i] * location_distribution[j])
                
                data.append({
                    "Year": year,
                    "Career": career,
                    "Job Growth (%)": growth_pattern[i],
                    "Job Openings": location_openings,
                    "Location": location
                })
    
    return pd.DataFrame(data)

def get_career_skills(career_path):
    """
    Returns required skills for a given career path.
    """
    # Dictionary of skills by career
    # In a full implementation, this would be fetched from a database or API
    skills_by_career = {
        "Software Engineer": {
            "Technical Skills": ["Programming (Python, JavaScript, etc.)", "Data Structures & Algorithms", "Version Control (Git)", "Database Knowledge", "Web Development"],
            "Soft Skills": ["Problem Solving", "Communication", "Teamwork", "Time Management", "Attention to Detail"],
            "Tools & Frameworks": ["Docker", "CI/CD", "Cloud Platforms (AWS, Azure, GCP)", "React/Angular/Vue", "Node.js"]
        },
        "Data Scientist": {
            "Technical Skills": ["Programming (Python, R)", "Statistics & Mathematics", "Machine Learning", "Data Visualization", "SQL"],
            "Soft Skills": ["Critical Thinking", "Communication", "Business Acumen", "Problem Solving", "Curiosity"],
            "Tools & Frameworks": ["Jupyter", "Pandas", "Scikit-learn", "TensorFlow/PyTorch", "Tableau/PowerBI"]
        },
        "UX/UI Designer": {
            "Technical Skills": ["UI Design", "User Research", "Wireframing", "Prototyping", "Information Architecture"],
            "Soft Skills": ["Empathy", "Communication", "Creativity", "Collaboration", "Attention to Detail"],
            "Tools & Frameworks": ["Figma", "Adobe XD", "Sketch", "InVision", "Zeplin"]
        }
    }
    
    # If career is in our database, return the skills
    if career_path in skills_by_career:
        return skills_by_career[career_path]
    
    # If career is not in our database, generate a reasonable response based on the career name
    # In a real implementation, this would fetch data from an API or database
    generic_skills = {
        "Technical Skills": ["Industry-specific knowledge", "Relevant software proficiency", "Data analysis", "Project management", "Technical writing"],
        "Soft Skills": ["Communication", "Problem Solving", "Teamwork", "Time Management", "Critical Thinking"],
        "Tools & Frameworks": ["Industry standard tools", "Productivity software", "Collaboration platforms", "Analytics tools", "CRM systems"]
    }
    
    return generic_skills

def get_salary_data(career_path):
    """
    Returns salary information for a given career path by experience level and location.
    """
    # Base salary tiers by career type
    # In a full implementation, this would be fetched from a salary database or API
    tech_careers = ["Software Engineer", "Data Scientist", "Cybersecurity Specialist", "Cloud Solutions Architect", "AI/ML Engineer"]
    healthcare_careers = ["Healthcare Administrator", "Nurse Practitioner", "Medical Technologist"]
    business_careers = ["Financial Analyst", "Business Analyst", "Product Manager", "Project Manager", "Management Consultant"]
    creative_careers = ["UX/UI Designer", "Graphic Designer", "Content Creator", "Digital Marketer"]
    
    # Determine which category the career falls into
    if career_path in tech_careers:
        base_salary = 85000
        multiplier = 1.2
    elif career_path in healthcare_careers:
        base_salary = 75000
        multiplier = 1.1
    elif career_path in business_careers:
        base_salary = 70000
        multiplier = 1.15
    elif career_path in creative_careers:
        base_salary = 65000
        multiplier = 1.05
    else:
        # Default for other careers
        base_salary = 60000
        multiplier = 1.0
    
    # Calculate salary by experience level
    salary_by_experience = {
        "Entry Level (0-2 years)": int(base_salary),
        "Mid Level (3-5 years)": int(base_salary * multiplier * 1.3),
        "Senior (6-10 years)": int(base_salary * multiplier * 1.7),
        "Lead/Manager (10+ years)": int(base_salary * multiplier * 2.2),
        "Executive": int(base_salary * multiplier * 3.0)
    }
    
    # Calculate salary by location
    salary_by_location = {
        "United States": int(base_salary * multiplier * 1.0),
        "Europe": int(base_salary * multiplier * 0.85),
        "Asia": int(base_salary * multiplier * 0.7),
        "Remote": int(base_salary * multiplier * 0.9)
    }
    
    return {
        "by_experience": salary_by_experience,
        "by_location": salary_by_location
    }
